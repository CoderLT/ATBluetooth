// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WCMmbpOpen.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "WcmmbpOpen.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma mark - WcmmbpOpenRoot

@implementation WcmmbpOpenRoot

@end

#pragma mark - WcmmbpOpenRoot_FileDescriptor

static GPBFileDescriptor *WcmmbpOpenRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"mmbp_open"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - MmBpOpen_BaseResponse

@implementation MmBpOpen_BaseResponse

@dynamic hasErrcode, errcode;
@dynamic hasErrmsg, errmsg;

typedef struct MmBpOpen_BaseResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t errcode;
  NSString *errmsg;
} MmBpOpen_BaseResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errcode",
        .number = MmBpOpen_BaseResponse_FieldNumber_Errcode,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(MmBpOpen_BaseResponse__storage_, errcode),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "errmsg",
        .number = MmBpOpen_BaseResponse_FieldNumber_Errmsg,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(MmBpOpen_BaseResponse__storage_, errmsg),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MmBpOpen_BaseResponse class]
                                     rootClass:[WcmmbpOpenRoot class]
                                          file:WcmmbpOpenRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(MmBpOpen_BaseResponse__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MmBpOpen_WristbandRequest

@implementation MmBpOpen_WristbandRequest

@dynamic stepDataArray, stepDataArray_Count;
@dynamic hasExtData, extData;

typedef struct MmBpOpen_WristbandRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *stepDataArray;
  NSData *extData;
} MmBpOpen_WristbandRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stepDataArray",
        .number = MmBpOpen_WristbandRequest_FieldNumber_StepDataArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(MmBpOpen_WristbandRequest__storage_, stepDataArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem),
        .fieldOptions = NULL,
      },
      {
        .name = "extData",
        .number = MmBpOpen_WristbandRequest_FieldNumber_ExtData,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
        .offset = offsetof(MmBpOpen_WristbandRequest__storage_, extData),
        .defaultValue.valueData = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\001\000StepData\000\002G\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MmBpOpen_WristbandRequest class]
                                     rootClass:[WcmmbpOpenRoot class]
                                          file:WcmmbpOpenRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(MmBpOpen_WristbandRequest__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem

@implementation MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem

@dynamic hasStep, step;
@dynamic hasTimestamp, timestamp;
@dynamic hasTimeStampRtcYear, timeStampRtcYear;
@dynamic hasTimeStampRtcMonth, timeStampRtcMonth;
@dynamic hasTimeStampRtcDay, timeStampRtcDay;
@dynamic hasTimeStampRtcHour, timeStampRtcHour;
@dynamic hasTimeStampRtcMinute, timeStampRtcMinute;
@dynamic hasTimeStampRtcSecond, timeStampRtcSecond;

typedef struct MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t step;
  uint32_t timestamp;
  uint32_t timeStampRtcYear;
  uint32_t timeStampRtcMonth;
  uint32_t timeStampRtcDay;
  uint32_t timeStampRtcHour;
  uint32_t timeStampRtcMinute;
  uint32_t timeStampRtcSecond;
} MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "step",
        .number = MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem_FieldNumber_Step,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_, step),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "timestamp",
        .number = MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem_FieldNumber_Timestamp,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_, timestamp),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "timeStampRtcYear",
        .number = MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem_FieldNumber_TimeStampRtcYear,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_, timeStampRtcYear),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "timeStampRtcMonth",
        .number = MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem_FieldNumber_TimeStampRtcMonth,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_, timeStampRtcMonth),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "timeStampRtcDay",
        .number = MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem_FieldNumber_TimeStampRtcDay,
        .hasIndex = 4,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_, timeStampRtcDay),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "timeStampRtcHour",
        .number = MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem_FieldNumber_TimeStampRtcHour,
        .hasIndex = 5,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_, timeStampRtcHour),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "timeStampRtcMinute",
        .number = MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem_FieldNumber_TimeStampRtcMinute,
        .hasIndex = 6,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_, timeStampRtcMinute),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "timeStampRtcSecond",
        .number = MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem_FieldNumber_TimeStampRtcSecond,
        .hasIndex = 7,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_, timeStampRtcSecond),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\010\001D\000\002I\000\003P\000\004Q\000\005O\000\006P\000\007R\000\010R\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem class]
                                     rootClass:[WcmmbpOpenRoot class]
                                          file:WcmmbpOpenRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(MmBpOpen_WristbandRequest_MmBpOpen_StepDataItem__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MmBpOpen_WristBandResponse

@implementation MmBpOpen_WristBandResponse

@dynamic hasBaseResp, baseResp;

typedef struct MmBpOpen_WristBandResponse__storage_ {
  uint32_t _has_storage_[1];
  MmBpOpen_BaseResponse *baseResp;
} MmBpOpen_WristBandResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .number = MmBpOpen_WristBandResponse_FieldNumber_BaseResp,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(MmBpOpen_WristBandResponse__storage_, baseResp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(MmBpOpen_BaseResponse),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001H\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MmBpOpen_WristBandResponse class]
                                     rootClass:[WcmmbpOpenRoot class]
                                          file:WcmmbpOpenRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(MmBpOpen_WristBandResponse__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MmBpOpen_WristBandPush

@implementation MmBpOpen_WristBandPush


typedef struct MmBpOpen_WristBandPush__storage_ {
  uint32_t _has_storage_[0];
} MmBpOpen_WristBandPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MmBpOpen_WristBandPush class]
                                     rootClass:[WcmmbpOpenRoot class]
                                          file:WcmmbpOpenRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(MmBpOpen_WristBandPush__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


// @@protoc_insertion_point(global_scope)
